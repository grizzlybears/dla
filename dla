#!/usr/bin/python2 -S
# -*- coding: utf-8 -*-
import sys
reload(sys)
sys.setdefaultencoding("utf-8")

import site
import traceback
import codecs
import os
import sqlite3
#import pprint
import subprocess

import his_loader
import db_operator
import analyzer
import data_struct 

MY_NAME='dla'

# 工具入口

def print_usage( argv0 = MY_NAME ):
    print "Usage:"
    print "  %s list        列出导入单个日线文件" % argv0
    print "  %s gen_alpha   <代码>  以<代码>为基准，设定其他代码的alpha" % argv0
    print "  %s correl      <代码1> <代码2> 考察指定两个代码的相关性 " % argv0
    print "  %s correl_all  [<代码列表文件>] 考察所有代码之间的相关性 " % argv0
    print "  %s show_correl 列出记录与DB的相关性关系 " % argv0
    print "  %s bt_faster_horse   <代码1> <代码2> 回测‘换快马’策略" % argv0
    print "  %s import      <日线文件>   导入单个日线文件" % argv0
    print "  %s importdir   <日线目录>   导入指定目录下所有日线文件(.txt) " % argv0


# 处理 'import' 子命令
def handle_import( argv, argv0 = MY_NAME ): 
    
    i = len(argv)
    if ( i < 1 ):
        print "  %s import    <日线文件>   导入单个日线文件" % argv0
        print "\n 未指定 <日报文件>\n"
        return 1

    try:
        # connect to DB 
        conn = db_operator.get_db_conn()
        dbcur = conn.cursor()
        inventory_ranges = db_operator.get_inventory(dbcur)

        # real stuff
        his_loader.load_some( argv[0] , dbcur, inventory_ranges)
        
        # DB clean up
        conn.commit()

    except  Exception as e:
        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(e) 
        
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e
        return 1
    finally:
        dbcur.close()
        conn.close()


    return 0

# 处理 'importdir' 子命令
def handle_importdir( argv, argv0 = MY_NAME ):
    i = len(argv)
    if ( i < 1 ):
        print "  %s importdir <日线目录>   导入指定目录下所有日线文件(.txt)" % argv0
        print "\n 未指定 <日线目录>\n"
        return 1

    myself = sys.argv[0]
    r = subprocess.call([ "find"
            , argv[0]
            , "-name"
            , "*.txt"
            , "-exec"
            , "./mac_csv_helper"
            , "{}"
            , ";"
            ])
    return r 

# 处理 'list' 子命令
def handle_list( argv, argv0 = MY_NAME ): 
    try:
        # connect to DB 
        conn = db_operator.get_db_conn()
        dbcur = conn.cursor()
        inventory_ranges = db_operator.get_inventory(dbcur)

        # real stuff
        analyzer.print_inventory( inventory_ranges)
        
        # DB clean up
        conn.commit()

    except  Exception as e:
        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(e) 
        
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e
        return 1 
    finally:
        dbcur.close()
        conn.close()

    return 0

# 处理 'show_correl' 子命令
def handle_show_correl( argv, argv0 = MY_NAME ): 
    try:
        # real stuff
        db_operator.show_correl()
        
    except  Exception as e:
        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(e) 
        
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e
        return 1 

    return 0



# 处理 'correl_all' 子命令
def handle_correl_all ( argv, argv0 = MY_NAME ): 
    try:
        # connect to DB 
        conn = db_operator.get_db_conn()
        dbcur = conn.cursor()


        inventory_ranges = {} 
 
        i = len(argv)
        if ( 1 == i  ):
            inventory_ranges = db_operator.get_inventory(dbcur)
            # 只关心列在文件里的那些代码
            codes_from_file = his_loader.codes_from_file( argv[0] )

            for k in inventory_ranges.keys():
                if k not in codes_from_file:
                    del inventory_ranges[k]

            analyzer.print_inventory( inventory_ranges)
        else:
            inventory_ranges = db_operator.get_inventory2(dbcur)
        
        # real stuff 
        analyzer.correlation_all( inventory_ranges,  dbcur)
        
               
        # DB clean up
        conn.commit()

    except  Exception as e:
        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(e) 
        
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e

        return 1
    finally:
        dbcur.close()
        conn.close()


    return 0


# 处理 'correl' 子命令
def handle_correl( argv, argv0 = MY_NAME ): 
    
    i = len(argv)
    if ( i < 2 ):
        print "  %s correl    <代码1> <代码2> 考察指定两个代码的相关性 " % argv0
        print "\n 未指定两个代码\n"
        return 1

    try:
        # connect to DB 
        conn = db_operator.get_db_conn()
        dbcur = conn.cursor()
        inventory_ranges = db_operator.get_inventory(dbcur)

        # real stuff
        code1 = argv[0]
        code2 = argv[1]

        if code1 not in inventory_ranges:
            print "%s not exists." % code1
            return 1 
        
        if code2 not in inventory_ranges:
            print "%s not exists." % code2
            return 1

        sec1 = inventory_ranges[code1]
        sec2 = inventory_ranges[code2]

        r_close,r_delta, num = analyzer.correlation(dbcur, sec1, sec2)
        print "%s %s , 收盘价关联度 = %f，涨跌幅关联度 = %f" % ( str(sec1), str(sec2), r_close, r_delta )
        
        # DB clean up
        conn.commit()

    except  Exception as e:
        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(e) 
        
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e

        return 1
    finally:
        dbcur.close()
        conn.close()


    return 0

# 处理 'bt_faster_horse' 子命令 , ‘换马’策略的回测
def handle_bt_faster_horse( argv, argv0 = MY_NAME ): 
    
    i = len(argv)
    if ( i < 2 ):
        print "  %s bt_faster_horse   <代码1> <代码2> 对指定两个代码进行‘换马’策略的回测 " % argv0
        print "\n 未指定两个代码\n"
        return 1

    try:
        # connect to DB 
        conn = db_operator.get_db_conn()
        dbcur = conn.cursor()
        inventory_ranges = db_operator.get_inventory(dbcur)

        # real stuff
        code1 = argv[0]
        code2 = argv[1]

        if code1 not in inventory_ranges:
            print "%s not exists." % code1
            return 1 
        
        if code2 not in inventory_ranges:
            print "%s not exists." % code2
            return 1

        sec1 = inventory_ranges[code1]
        sec2 = inventory_ranges[code2]

        net_value, num = analyzer.bt_faster_horse(dbcur, sec1, sec2)
        print "%s %s ‘换快马’, %d 交易日，净值 %f" % ( str(sec1), str(sec2), num, net_value)
        
        # DB clean up
        conn.commit()

    except  Exception as e:
        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(e) 
        
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e

        return 1
    finally:
        dbcur.close()
        conn.close()


    return 0



# 处理 'gen_alpha' 子命令
def handle_gen_alpha( argv, argv0 = MY_NAME ): 
    
    i = len(argv)
    if ( i < 1 ):
        print "  %s gen_alpha  <代码>  以<代码>为基准，设定其他代码的alpha" % argv0
        print "\n 未指定<代码>\n"
        return 1

    try:
        # connect to DB 
        conn = db_operator.get_db_conn()
        dbcur = conn.cursor()
        inventory_ranges = db_operator.get_inventory(dbcur)

        # real stuff
        code1 = argv[0]
        analyzer.gen_alpha(dbcur, code1 )
        
        # DB clean up
        conn.commit()

    except  Exception as e:
        (t, v, bt) = sys.exc_info()
        traceback.print_exception(t, v, bt)

        print
        print e
        return 1
    finally:
        dbcur.close()
        conn.close()


    return 0


def make_sure_working_dir():
    r = subprocess.call([ "mkdir"
            , "-p"
            , data_struct.WORKING_DIR 
            ])

    if 0 != r:
        raise Exception("Failed to make '%s'" % data_struct.WORKING_DIR );

#    subprocess.call([ "ln "
#            , "-s"
#            , "%s/ggchart_loader.js" % data_struct.JSLIB 
#            , data_struct.WORKING_DIR 
#            ])

def main(): 
    i = len(sys.argv)
    if ( i < 2 ):
        print_usage()
        return 1

    make_sure_working_dir()

    sub_command = sys.argv[1]

    if ('import' == sub_command ):
        return handle_import ( sys.argv[2:] ) 
    elif ('importdir' == sub_command ):
        return handle_importdir ( sys.argv[2:] )  
    elif ('list' == sub_command ):
        return handle_list ( sys.argv[2:] )  
    elif ('show_correl' == sub_command ):
        return handle_show_correl ( sys.argv[2:] ) 
    elif ('correl' == sub_command ):
        return handle_correl ( sys.argv[2:] )  
    elif ('correl_all' == sub_command ):
        return handle_correl_all ( sys.argv[2:] )  
    elif ('gen_alpha' == sub_command ):
        return handle_gen_alpha ( sys.argv[2:] ) 
    elif ('bt_faster_horse' == sub_command ):
        return handle_bt_faster_horse ( sys.argv[2:] )   
    elif ('help' == sub_command ):
        print_usage()
        return 1
    else:
        print "\n无效的‘子命令’ -- %s\n" % ( sub_command, )
        print_usage()
        return 1

    return 0

if __name__ == "__main__":
    r = main()
    sys.exit(r)


